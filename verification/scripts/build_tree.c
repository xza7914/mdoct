
// generated by gen_tree from try.json

#include <stdlib.h>
#include "state_tree.h"

struct tree_node *build_tree()
{
	struct tree_node *root = malloc(sizeof(struct tree_node));
	__CPROVER_assume(root != NULL);

	root->len = 6;
	root->children = malloc(sizeof(struct item) * 6);
	__CPROVER_assume(root->children != NULL);

	struct tree_node *node1_1 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node1_1 != NULL);

	node1_1->len = 4;
	node1_1->children = malloc(sizeof(struct item) * 4);
	__CPROVER_assume(node1_1->children != NULL);

	struct tree_node *node2_1 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_1 != NULL);

	node1_1->children[0].child = node2_1;

	struct tree_node *node2_2 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_2 != NULL);

	node1_1->children[1].child = node2_2;

	struct tree_node *node2_4 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_4 != NULL);

	node1_1->children[2].child = node2_4;

	struct tree_node *node2_5 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_5 != NULL);

	node1_1->children[3].child = node2_5;

	root->children[0].child = node1_1;

	struct tree_node *node1_2 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node1_2 != NULL);

	node1_2->len = 3;
	node1_2->children = malloc(sizeof(struct item) * 3);
	__CPROVER_assume(node1_2->children != NULL);

	struct tree_node *node2_6 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_6 != NULL);

	node1_2->children[0].child = node2_6;

	struct tree_node *node2_7 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_7 != NULL);

	node1_2->children[1].child = node2_7;

	struct tree_node *node2_8 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_8 != NULL);

	node2_8->len = 2;
	node2_8->children = malloc(sizeof(struct item) * 2);
	__CPROVER_assume(node2_8->children != NULL);

	struct tree_node *node3_1 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node3_1 != NULL);

	node2_8->children[0].child = node3_1;

	struct tree_node *node3_2 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node3_2 != NULL);

	node2_8->children[1].child = node3_2;

	node1_2->children[2].child = node2_8;

	root->children[1].child = node1_2;

	struct tree_node *node1_3 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node1_3 != NULL);

	node1_3->len = 2;
	node1_3->children = malloc(sizeof(struct item) * 2);
	__CPROVER_assume(node1_3->children != NULL);

	struct tree_node *node2_9 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_9 != NULL);

	node2_9->len = 2;
	node2_9->children = malloc(sizeof(struct item) * 2);
	__CPROVER_assume(node2_9->children != NULL);

	struct tree_node *node3_3 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node3_3 != NULL);

	node2_9->children[0].child = node3_3;

	struct tree_node *node3_4 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node3_4 != NULL);

	node2_9->children[1].child = node3_4;

	node1_3->children[0].child = node2_9;

	struct tree_node *node2_10 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_10 != NULL);

	node1_3->children[1].child = node2_10;

	root->children[2].child = node1_3;

	struct tree_node *node1_4 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node1_4 != NULL);

	node1_4->len = 2;
	node1_4->children = malloc(sizeof(struct item) * 2);
	__CPROVER_assume(node1_4->children != NULL);

	struct tree_node *node2_11 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_11 != NULL);

	node1_4->children[0].child = node2_11;

	struct tree_node *node2_12 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_12 != NULL);

	node1_4->children[1].child = node2_12;

	root->children[3].child = node1_4;

	struct tree_node *node1_5 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node1_5 != NULL);

	node1_5->len = 5;
	node1_5->children = malloc(sizeof(struct item) * 5);
	__CPROVER_assume(node1_5->children != NULL);

	struct tree_node *node2_13 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_13 != NULL);

	node1_5->children[0].child = node2_13;

	struct tree_node *node2_14 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_14 != NULL);

	node1_5->children[1].child = node2_14;

	struct tree_node *node2_15 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_15 != NULL);

	node1_5->children[2].child = node2_15;

	struct tree_node *node2_16 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_16 != NULL);

	node1_5->children[3].child = node2_16;

	struct tree_node *node2_17 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node2_17 != NULL);

	node1_5->children[4].child = node2_17;

	root->children[4].child = node1_5;

	struct tree_node *node1_6 = malloc(sizeof(struct tree_node));
	__CPROVER_assume(node1_6 != NULL);

	root->children[5].child = node1_6;


return root;

}
